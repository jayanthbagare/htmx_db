-- Business Logic Functions
-- Module: Goods Receipts
-- Description: Goods receipt create, accept, reject workflow
-- Author: happyveggie & Claude Opus 4.5

-- =============================================================================
-- FUNCTION: Create Goods Receipt
-- =============================================================================
-- Creates a goods receipt for an approved PO

CREATE OR REPLACE FUNCTION create_goods_receipt(
    p_user_id UUID,
    p_po_id UUID,
    p_receipt_date DATE DEFAULT CURRENT_DATE,
    p_delivery_note_number VARCHAR DEFAULT NULL,
    p_notes TEXT DEFAULT NULL,
    p_lines JSONB DEFAULT '[]'::JSONB
)
RETURNS JSONB AS $$
DECLARE
    v_gr_id UUID;
    v_gr_number VARCHAR;
    v_po_record RECORD;
    v_line JSONB;
    v_line_id UUID;
    v_po_line RECORD;
    v_qty_received DECIMAL(15,4);
    v_qty_remaining DECIMAL(15,4);
    v_lines_created INTEGER := 0;
BEGIN
    -- Validate user has create permission for goods receipts
    IF NOT can_user_perform_action(p_user_id, 'goods_receipt', 'create') THEN
        RAISE EXCEPTION 'User does not have permission to create goods receipts';
    END IF;

    -- Validate PO exists and is in approved status
    SELECT po_id, po_number, status, supplier_id
    INTO v_po_record
    FROM purchase_orders
    WHERE po_id = p_po_id
      AND is_deleted = FALSE;

    IF v_po_record IS NULL THEN
        RAISE EXCEPTION 'Purchase order not found: %', p_po_id;
    END IF;

    IF v_po_record.status NOT IN ('approved', 'partially_received') THEN
        RAISE EXCEPTION 'Cannot receive goods for PO with status: %. Must be approved.', v_po_record.status;
    END IF;

    -- Generate GR ID
    v_gr_id := gen_random_uuid();

    -- Create the goods receipt (gr_number will be auto-generated by trigger)
    INSERT INTO goods_receipts (
        gr_id,
        po_id,
        receipt_date,
        delivery_note_number,
        received_by,
        quality_status,
        notes,
        created_by,
        created_at
    ) VALUES (
        v_gr_id,
        p_po_id,
        p_receipt_date,
        p_delivery_note_number,
        p_user_id,
        'pending',
        p_notes,
        p_user_id,
        NOW()
    )
    RETURNING gr_number INTO v_gr_number;

    -- Create line items
    -- If no lines provided, create lines for all PO lines with remaining quantity
    IF jsonb_array_length(p_lines) = 0 THEN
        -- Auto-create lines for all unreceived items
        FOR v_po_line IN
            SELECT
                pol.line_id,
                pol.line_number,
                pol.item_code,
                pol.item_description,
                pol.quantity_ordered,
                pol.quantity_received,
                pol.uom
            FROM purchase_order_lines pol
            WHERE pol.po_id = p_po_id
              AND pol.is_deleted = FALSE
              AND pol.quantity_received < pol.quantity_ordered
            ORDER BY pol.line_number
        LOOP
            v_qty_remaining := v_po_line.quantity_ordered - v_po_line.quantity_received;
            v_line_id := gen_random_uuid();

            INSERT INTO goods_receipt_lines (
                gr_line_id,
                gr_id,
                po_line_id,
                line_number,
                quantity_received,
                quantity_accepted,
                quantity_rejected,
                uom,
                storage_location,
                created_at
            ) VALUES (
                v_line_id,
                v_gr_id,
                v_po_line.line_id,
                v_po_line.line_number,
                v_qty_remaining,
                0,  -- Will be set on accept
                0,
                v_po_line.uom,
                NULL,
                NOW()
            );

            v_lines_created := v_lines_created + 1;
        END LOOP;
    ELSE
        -- Create lines from provided data
        FOR v_line IN SELECT * FROM jsonb_array_elements(p_lines)
        LOOP
            -- Get PO line info
            SELECT line_id, line_number, quantity_ordered, quantity_received, uom
            INTO v_po_line
            FROM purchase_order_lines
            WHERE line_id = (v_line->>'po_line_id')::UUID
              AND po_id = p_po_id
              AND is_deleted = FALSE;

            IF v_po_line IS NULL THEN
                RAISE EXCEPTION 'Invalid PO line: %', v_line->>'po_line_id';
            END IF;

            v_qty_received := COALESCE((v_line->>'quantity_received')::DECIMAL, 0);
            v_qty_remaining := v_po_line.quantity_ordered - v_po_line.quantity_received;

            -- Validate quantity doesn't exceed remaining
            IF v_qty_received > v_qty_remaining THEN
                RAISE EXCEPTION 'Quantity received (%) exceeds remaining quantity (%) for line %',
                    v_qty_received, v_qty_remaining, v_po_line.line_number;
            END IF;

            v_line_id := gen_random_uuid();

            INSERT INTO goods_receipt_lines (
                gr_line_id,
                gr_id,
                po_line_id,
                line_number,
                quantity_received,
                quantity_accepted,
                quantity_rejected,
                uom,
                storage_location,
                created_at
            ) VALUES (
                v_line_id,
                v_gr_id,
                v_po_line.line_id,
                v_po_line.line_number,
                v_qty_received,
                0,
                0,
                v_po_line.uom,
                v_line->>'storage_location',
                NOW()
            );

            v_lines_created := v_lines_created + 1;
        END LOOP;
    END IF;

    IF v_lines_created = 0 THEN
        -- Rollback - no lines created means nothing to receive
        DELETE FROM goods_receipts WHERE gr_id = v_gr_id;
        RAISE EXCEPTION 'No items to receive - all quantities already received';
    END IF;

    -- Return the created GR
    RETURN jsonb_build_object(
        'success', TRUE,
        'gr_id', v_gr_id,
        'gr_number', v_gr_number,
        'po_number', v_po_record.po_number,
        'line_count', v_lines_created,
        'quality_status', 'pending',
        'message', 'Goods receipt created successfully. Pending quality check.'
    );

EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object(
        'success', FALSE,
        'error', SQLERRM
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION create_goods_receipt(UUID, UUID, DATE, VARCHAR, TEXT, JSONB) IS 'Creates a goods receipt for a PO';

-- =============================================================================
-- FUNCTION: Accept Goods Receipt
-- =============================================================================
-- Marks a goods receipt as accepted (passed quality check)

CREATE OR REPLACE FUNCTION accept_goods_receipt(
    p_user_id UUID,
    p_gr_id UUID,
    p_notes TEXT DEFAULT NULL
)
RETURNS JSONB AS $$
DECLARE
    v_gr_record RECORD;
    v_po_id UUID;
BEGIN
    -- Validate user has approve permission
    IF NOT can_user_perform_action(p_user_id, 'goods_receipt', 'approve') THEN
        RAISE EXCEPTION 'User does not have permission to accept goods receipts';
    END IF;

    -- Get GR info
    SELECT gr_id, gr_number, po_id, quality_status
    INTO v_gr_record
    FROM goods_receipts
    WHERE gr_id = p_gr_id
      AND is_deleted = FALSE;

    IF v_gr_record IS NULL THEN
        RAISE EXCEPTION 'Goods receipt not found: %', p_gr_id;
    END IF;

    IF v_gr_record.quality_status != 'pending' THEN
        RAISE EXCEPTION 'Cannot accept GR with status: %. Already processed.', v_gr_record.quality_status;
    END IF;

    v_po_id := v_gr_record.po_id;

    -- Update GR status and accept all quantities
    UPDATE goods_receipts
    SET quality_status = 'accepted',
        quality_checked_by = p_user_id,
        quality_checked_at = NOW(),
        quality_notes = p_notes,
        updated_at = NOW(),
        updated_by = p_user_id
    WHERE gr_id = p_gr_id;

    -- Set accepted quantities on lines (accept all received)
    UPDATE goods_receipt_lines
    SET quantity_accepted = quantity_received,
        quantity_rejected = 0
    WHERE gr_id = p_gr_id
      AND is_deleted = FALSE;

    -- Update PO line quantities
    PERFORM update_po_line_quantities(v_po_id, 'received');

    RETURN jsonb_build_object(
        'success', TRUE,
        'gr_id', p_gr_id,
        'gr_number', v_gr_record.gr_number,
        'old_status', 'pending',
        'new_status', 'accepted',
        'message', 'Goods receipt accepted. PO quantities updated.'
    );

EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object(
        'success', FALSE,
        'error', SQLERRM
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION accept_goods_receipt(UUID, UUID, TEXT) IS 'Accepts a goods receipt after quality check';

-- =============================================================================
-- FUNCTION: Reject Goods Receipt
-- =============================================================================
-- Marks a goods receipt as rejected (failed quality check)

CREATE OR REPLACE FUNCTION reject_goods_receipt(
    p_user_id UUID,
    p_gr_id UUID,
    p_rejection_reason TEXT
)
RETURNS JSONB AS $$
DECLARE
    v_gr_record RECORD;
BEGIN
    -- Validate user has approve permission
    IF NOT can_user_perform_action(p_user_id, 'goods_receipt', 'approve') THEN
        RAISE EXCEPTION 'User does not have permission to reject goods receipts';
    END IF;

    -- Validate rejection reason
    IF p_rejection_reason IS NULL OR TRIM(p_rejection_reason) = '' THEN
        RAISE EXCEPTION 'Rejection reason is required';
    END IF;

    -- Get GR info
    SELECT gr_id, gr_number, po_id, quality_status
    INTO v_gr_record
    FROM goods_receipts
    WHERE gr_id = p_gr_id
      AND is_deleted = FALSE;

    IF v_gr_record IS NULL THEN
        RAISE EXCEPTION 'Goods receipt not found: %', p_gr_id;
    END IF;

    IF v_gr_record.quality_status != 'pending' THEN
        RAISE EXCEPTION 'Cannot reject GR with status: %. Already processed.', v_gr_record.quality_status;
    END IF;

    -- Update GR status
    UPDATE goods_receipts
    SET quality_status = 'rejected',
        quality_checked_by = p_user_id,
        quality_checked_at = NOW(),
        quality_notes = p_rejection_reason,
        updated_at = NOW(),
        updated_by = p_user_id
    WHERE gr_id = p_gr_id;

    -- Set rejected quantities on lines (reject all received)
    UPDATE goods_receipt_lines
    SET quantity_rejected = quantity_received,
        quantity_accepted = 0
    WHERE gr_id = p_gr_id
      AND is_deleted = FALSE;

    -- Note: We don't update PO quantities for rejected goods
    -- The rejected goods will need to be re-ordered or re-received

    RETURN jsonb_build_object(
        'success', TRUE,
        'gr_id', p_gr_id,
        'gr_number', v_gr_record.gr_number,
        'old_status', 'pending',
        'new_status', 'rejected',
        'rejection_reason', p_rejection_reason,
        'message', 'Goods receipt rejected. Items not added to inventory.'
    );

EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object(
        'success', FALSE,
        'error', SQLERRM
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION reject_goods_receipt(UUID, UUID, TEXT) IS 'Rejects a goods receipt after failed quality check';

-- =============================================================================
-- FUNCTION: Partially Accept Goods Receipt
-- =============================================================================
-- Accepts some items and rejects others

CREATE OR REPLACE FUNCTION partial_accept_goods_receipt(
    p_user_id UUID,
    p_gr_id UUID,
    p_lines JSONB,  -- [{gr_line_id, quantity_accepted, quantity_rejected, reason}]
    p_notes TEXT DEFAULT NULL
)
RETURNS JSONB AS $$
DECLARE
    v_gr_record RECORD;
    v_line JSONB;
    v_gr_line RECORD;
    v_total_accepted DECIMAL := 0;
    v_total_rejected DECIMAL := 0;
    v_po_id UUID;
BEGIN
    -- Validate user has approve permission
    IF NOT can_user_perform_action(p_user_id, 'goods_receipt', 'approve') THEN
        RAISE EXCEPTION 'User does not have permission to process goods receipts';
    END IF;

    -- Get GR info
    SELECT gr_id, gr_number, po_id, quality_status
    INTO v_gr_record
    FROM goods_receipts
    WHERE gr_id = p_gr_id
      AND is_deleted = FALSE;

    IF v_gr_record IS NULL THEN
        RAISE EXCEPTION 'Goods receipt not found: %', p_gr_id;
    END IF;

    IF v_gr_record.quality_status != 'pending' THEN
        RAISE EXCEPTION 'Cannot process GR with status: %. Already processed.', v_gr_record.quality_status;
    END IF;

    v_po_id := v_gr_record.po_id;

    -- Process each line
    FOR v_line IN SELECT * FROM jsonb_array_elements(p_lines)
    LOOP
        -- Get GR line
        SELECT gr_line_id, quantity_received
        INTO v_gr_line
        FROM goods_receipt_lines
        WHERE gr_line_id = (v_line->>'gr_line_id')::UUID
          AND gr_id = p_gr_id
          AND is_deleted = FALSE;

        IF v_gr_line IS NULL THEN
            RAISE EXCEPTION 'Invalid GR line: %', v_line->>'gr_line_id';
        END IF;

        -- Validate quantities
        IF COALESCE((v_line->>'quantity_accepted')::DECIMAL, 0) +
           COALESCE((v_line->>'quantity_rejected')::DECIMAL, 0) != v_gr_line.quantity_received THEN
            RAISE EXCEPTION 'Accepted + Rejected must equal received quantity for line %', v_gr_line.gr_line_id;
        END IF;

        -- Update line
        UPDATE goods_receipt_lines
        SET quantity_accepted = COALESCE((v_line->>'quantity_accepted')::DECIMAL, 0),
            quantity_rejected = COALESCE((v_line->>'quantity_rejected')::DECIMAL, 0),
            rejection_reason = v_line->>'reason'
        WHERE gr_line_id = v_gr_line.gr_line_id;

        v_total_accepted := v_total_accepted + COALESCE((v_line->>'quantity_accepted')::DECIMAL, 0);
        v_total_rejected := v_total_rejected + COALESCE((v_line->>'quantity_rejected')::DECIMAL, 0);
    END LOOP;

    -- Determine final status
    UPDATE goods_receipts
    SET quality_status = CASE
            WHEN v_total_rejected = 0 THEN 'accepted'
            WHEN v_total_accepted = 0 THEN 'rejected'
            ELSE 'partial'
        END,
        quality_checked_by = p_user_id,
        quality_checked_at = NOW(),
        quality_notes = p_notes,
        updated_at = NOW(),
        updated_by = p_user_id
    WHERE gr_id = p_gr_id;

    -- Update PO line quantities (only for accepted items)
    PERFORM update_po_line_quantities(v_po_id, 'received');

    RETURN jsonb_build_object(
        'success', TRUE,
        'gr_id', p_gr_id,
        'gr_number', v_gr_record.gr_number,
        'total_accepted', v_total_accepted,
        'total_rejected', v_total_rejected,
        'message', 'Goods receipt processed. ' || v_total_accepted || ' accepted, ' || v_total_rejected || ' rejected.'
    );

EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object(
        'success', FALSE,
        'error', SQLERRM
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION partial_accept_goods_receipt(UUID, UUID, JSONB, TEXT) IS 'Partially accepts a goods receipt';

-- =============================================================================
-- EXAMPLES AND TESTS
-- =============================================================================

/*
-- Create a goods receipt for a PO
SELECT create_goods_receipt(
    '00000000-0000-0000-0000-000000000100'::UUID,  -- user_id
    (SELECT po_id FROM purchase_orders WHERE status = 'approved' LIMIT 1),
    CURRENT_DATE,
    'DN-12345',
    'Received in good condition'
);

-- Accept the goods receipt
SELECT accept_goods_receipt(
    '00000000-0000-0000-0000-000000000100'::UUID,
    (SELECT gr_id FROM goods_receipts ORDER BY created_at DESC LIMIT 1),
    'All items passed QC'
);

-- Reject the goods receipt
SELECT reject_goods_receipt(
    '00000000-0000-0000-0000-000000000100'::UUID,
    (SELECT gr_id FROM goods_receipts WHERE quality_status = 'pending' LIMIT 1),
    'Items damaged in transit'
);
*/
