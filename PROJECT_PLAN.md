# Database-Driven HTMX UI Generation System
## Project Plan & Architecture Documentation

**Project Type**: Database-Centric UI Generation System
**Domain**: Procurement Workflow (Purchase-to-Pay Cycle)
**Status**: Planning Phase
**Planned Duration**: 30 days

**Contributors**:
- Project Lead: happyveggie
- Architecture & Planning: Claude Sonnet 4.5 (Anthropic)

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Project Overview](#project-overview)
3. [Architecture & Design](#architecture--design)
4. [Technology Stack](#technology-stack)
5. [Database Schema](#database-schema)
6. [Core Components](#core-components)
7. [Implementation Phases](#implementation-phases)
8. [Testing Strategy](#testing-strategy)
9. [Success Metrics](#success-metrics)
10. [Risk Management](#risk-management)

---

## Executive Summary

This project implements a novel approach to web application development where **PostgreSQL generates complete HTMX user interfaces** dynamically. Instead of traditional application-layer templating, all UI generation, business logic, and permission enforcement happens in the database layer, with a minimal Node.js API serving as a thin proxy.

### Key Innovations

- **Database-First Architecture**: UI structure, templates, and permissions stored in database
- **Dynamic HTMX Generation**: Complete HTML responses generated by PostgreSQL functions
- **Granular Permission System**: Field-level and action-level permissions enforced at database layer
- **Complete Business Logic in DB**: No business logic in application layer

### Business Value

- **Rapid Development**: Add new entities without writing application code
- **Centralized Logic**: Single source of truth for business rules
- **Consistent Security**: Permission enforcement cannot be bypassed
- **Performance**: Database-optimized queries with intelligent caching

---

## Project Overview

### Business Domain: Procurement Workflow

The system manages a complete Purchase-to-Pay (P2P) cycle:

```
Purchase Order → Goods Receipt → Invoice Receipt → Payment → Clearing
     ↓                ↓                  ↓              ↓          ↓
  (Create,        (Updates PO      (3-way match)  (Validates)  (Reconciles)
   Submit,         quantities)
   Approve)
```

### Core Entities

1. **Suppliers** - Vendor master data
2. **Purchase Orders** - Procurement requests with line items
3. **Goods Receipts** - Receiving documents
4. **Invoice Receipts** - Vendor invoices with 3-way matching
5. **Payments** - Payment records
6. **Clearing Entries** - Payment-to-invoice reconciliation

### Key Features

- Role-based access control with 5 standard roles
- Field-level permission granularity (visible/editable by role and view type)
- Dynamic UI generation from database metadata
- Complete audit trail (who created, who approved, when)
- Soft deletes for data retention
- 3-way matching (PO-GR-Invoice) with variance detection
- Real-time performance monitoring

---

## Architecture & Design

### Database-First Philosophy

```
┌─────────────────────────────────────────────────────────┐
│                     PostgreSQL                          │
│                                                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │   Business   │  │ UI Framework │  │   Audit &    │ │
│  │    Domain    │  │   Tables     │  │ Performance  │ │
│  │  (9 tables)  │  │  (7 tables)  │  │  (2 tables)  │ │
│  └──────────────┘  └──────────────┘  └──────────────┘ │
│                                                         │
│  ┌──────────────────────────────────────────────────┐  │
│  │         PostgreSQL Functions (PL/pgSQL)          │  │
│  ├──────────────────────────────────────────────────┤  │
│  │ • Template Rendering Engine                      │  │
│  │ • Permission Resolution                          │  │
│  │ • Dynamic Query Builder                          │  │
│  │ • HTMX Generation (lists, forms)                 │  │
│  │ • Business Workflow Logic                        │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────┐
│            Fastify API (Minimal Proxy Layer)            │
│  • Authentication (Supabase Auth)                       │
│  • Routing to database functions                       │
│  • Error handling & logging                            │
└─────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────┐
│                    Browser (HTMX)                       │
│  • Receives server-generated HTML                       │
│  • HTMX handles all interactivity                       │
│  • No JavaScript framework needed                       │
└─────────────────────────────────────────────────────────┘
```

### Permission Model

Multi-level security enforcement:

**Level 1: Action Permissions (Entity-Level)**
- Can user perform this action on this entity type?
- Actions: create, edit, delete, approve, submit, cancel
- Example: "purchase_manager can create purchase_orders"

**Level 2: Field Permissions (Field-Level)**
- Can user see/edit this specific field in this view?
- Views: list, form_create, form_edit, form_view
- Example: "warehouse_staff cannot see total_amount in any view"

**Level 3: Row-Level Security (Data-Level)**
- Can user access this specific record?
- Implemented via PostgreSQL RLS policies
- Example: "users can only see their own draft POs"

---

## Technology Stack

### Database Layer
- **PostgreSQL 14+** (via Supabase)
- **Extensions**: uuid-ossp, pg_stat_statements
- **Language**: PL/pgSQL for all functions

### API Layer
- **Runtime**: Node.js 18+
- **Framework**: Fastify (for performance)
- **Database Client**: Supabase JS Client
- **Authentication**: Supabase Auth

### Frontend
- **Interactivity**: HTMX 1.9+
- **Styling**: Tailwind CSS or minimal CSS
- **JavaScript**: None (HTMX handles everything)

### Testing & Tools
- **Database Tests**: pgTAP
- **Integration Tests**: Jest + Supertest
- **Load Testing**: k6 or Artillery
- **Test Data**: Faker.js
- **Performance Monitoring**: pg_stat_statements, custom logging

### Development Tools
- **Version Control**: Git + GitHub
- **Database Management**: Supabase CLI, DBeaver, or pgAdmin
- **API Testing**: Postman or HTTPie
- **CI/CD**: GitHub Actions

---

## Database Schema

### Schema Organization (18 Tables Total)

#### A. Business Domain Tables (9)

**suppliers**
```sql
- supplier_id (UUID, PK)
- supplier_code (VARCHAR(50), UNIQUE)
- supplier_name (VARCHAR(200))
- contact_email, contact_phone
- payment_terms_days (INTEGER)
- is_active, created_at, updated_at, created_by
```

**purchase_orders**
```sql
- po_id (UUID, PK)
- po_number (VARCHAR(50), UNIQUE)
- supplier_id (FK to suppliers)
- po_date, expected_delivery_date
- total_amount (DECIMAL(15,2))
- currency (VARCHAR(3))
- status (draft/submitted/approved/partially_received/fully_received/cancelled)
- notes, is_deleted
- created_at, updated_at, created_by
- approved_by, approved_at
```

**purchase_order_lines**
```sql
- po_line_id (UUID, PK)
- po_id (FK to purchase_orders)
- line_number, item_code, item_description
- quantity_ordered, unit_price, line_total
- quantity_received, quantity_invoiced (tracking fields)
- uom, is_deleted
```

**goods_receipts** + **goods_receipt_lines**
```sql
- Tracks physical receipt of goods
- Updates quantity_received on PO lines
- Includes quality_status (accepted/rejected/pending_inspection)
```

**invoice_receipts** + **invoice_lines**
```sql
- Vendor invoices
- 3-way matching against PO and GR
- matching_status (pending/matched/variance)
- variance_amount calculation
```

**payments**
```sql
- Payment records against invoices
- payment_method (bank_transfer/check/wire/credit_card)
- status (pending/processed/cleared/failed/cancelled)
```

**clearing_entries**
```sql
- Links payments to invoices
- Final reconciliation step
- cleared_amount, clearing_date
```

#### B. UI Generation Framework Tables (7)

**ui_entity_types**
```sql
- Defines each business entity
- Links to primary_table name
- Display name, icon, description
```

**ui_field_definitions**
```sql
- Complete field metadata for each entity
- data_type (text/number/date/select/textarea/lookup)
- field_order, is_required
- validation_rule (JSON)
- lookup_entity, lookup_display_field
- default_value, help_text
```

**htmx_templates**
```sql
- Stores HTML templates with placeholders
- view_type (list/form_create/form_edit/form_view/filter_panel)
- base_template (TEXT with {{placeholder}} syntax)
- version, is_active
```

**roles** + **users**
```sql
- User authentication and role assignment
- 5 standard roles: admin, purchase_manager, warehouse_staff, accountant, viewer
```

**field_permissions**
```sql
- Field-level permissions per role
- Separate flags for: list_visible, list_editable, form_create_visible, etc.
- UNIQUE(role_id, field_id)
```

**ui_action_permissions**
```sql
- Action-level permissions per role
- action_name (create/edit/delete/approve/submit/cancel)
- is_allowed
- condition_rule (JSON for dynamic conditions)
```

#### C. Audit & Performance Tables (2)

**ui_generation_logs**
```sql
- Logs every UI generation request
- Captures: duration_ms, cache_hit, data_row_count
- Error tracking
- Performance analysis data
```

**performance_metrics**
```sql
- Aggregated performance data
- avg_response_time_ms, p95, p99
- request_count, error_count
- Used for dashboards
```

### Key Design Decisions

1. **UUIDs vs Serial**: UUIDs for security and distributed systems
2. **Soft Deletes**: `is_deleted` flags preserve referential integrity
3. **Audit Fields**: Every table has created_at, updated_at, created_by
4. **Status Fields**: VARCHAR with CHECK constraints (not ENUMs)
5. **Decimal for Money**: DECIMAL(15,2) not FLOAT
6. **Template Versioning**: version + is_active for A/B testing

### Indexing Strategy

```sql
-- Primary keys: Automatic clustered indexes
-- Foreign keys: All indexed for joins
CREATE INDEX idx_po_supplier ON purchase_orders(supplier_id);

-- Filter fields: Status, dates, is_deleted
CREATE INDEX idx_po_status ON purchase_orders(status) WHERE is_deleted = FALSE;
CREATE INDEX idx_po_date ON purchase_orders(po_date);

-- Composite indexes for common queries
CREATE INDEX idx_po_status_date ON purchase_orders(status, po_date)
  WHERE is_deleted = FALSE;

-- Lookup optimization
CREATE INDEX idx_po_lines_po ON purchase_order_lines(po_id)
  WHERE is_deleted = FALSE;
```

---

## Core Components

### 1. Template Rendering Engine

**Objective**: Replace placeholders in HTML templates with actual data

**Functions**:
```sql
CREATE FUNCTION render_template(p_template TEXT, p_data JSONB) RETURNS TEXT
```

**Features**:
- Simple placeholders: `{{field_name}}` → actual value
- Nested paths: `{{supplier.name}}` → navigate JSON
- Array iteration: `{{#lines}}...{{/lines}}` → loop over arrays
- Conditionals: `{{#if status == 'approved'}}...{{/if}}`
- HTML escaping: Prevent XSS attacks
- Triple mustache for raw HTML: `{{{raw_html}}}`

**Template Example**:
```html
<tr hx-get="/ui/purchase_order/form/view?id={{po_id}}" hx-target="#modal">
    <td>{{po_number}}</td>
    <td>{{supplier.supplier_name}}</td>
    <td>{{po_date}}</td>
    <td>{{total_amount}}</td>
    <td><span class="status-{{status}}">{{status}}</span></td>
</tr>
```

**Permission Integration**:
```sql
CREATE FUNCTION apply_field_permissions(
    p_template TEXT,
    p_visible_fields TEXT[],
    p_editable_fields TEXT[]
) RETURNS TEXT
```
- Removes hidden fields from template
- Adds `disabled` attribute to non-editable fields

### 2. Permission Resolution System

**Functions**:
```sql
-- Get field permissions for user
CREATE FUNCTION get_user_field_permissions(
    p_user_id UUID,
    p_entity_type VARCHAR,
    p_view_type VARCHAR
) RETURNS TABLE (field_name VARCHAR, is_visible BOOLEAN, is_editable BOOLEAN)

-- Check if user can perform action
CREATE FUNCTION can_user_perform_action(
    p_user_id UUID,
    p_entity_type VARCHAR,
    p_action_name VARCHAR,
    p_record_data JSONB DEFAULT NULL
) RETURNS BOOLEAN

-- Evaluate dynamic conditions
CREATE FUNCTION evaluate_condition(
    p_condition JSONB,
    p_record JSONB,
    p_user_id UUID
) RETURNS BOOLEAN
```

**Example Permission Check**:
```sql
-- Can purchase_manager approve POs?
SELECT can_user_perform_action(
    '123e4567-e89b-12d3-a456-426614174000',
    'purchase_order',
    'approve'
);
-- Returns: FALSE (only admins can approve)
```

**Caching Strategy**:
- Cache permissions for 5 minutes per (user_id, entity_type, view_type)
- Invalidate on role change or permission update
- Cache key: `perms:${user_id}:${entity_type}:${view_type}`

### 3. Dynamic Query Builder

**Functions**:
```sql
-- Build dynamic WHERE clause from filters
CREATE FUNCTION build_where_clause(p_filters JSONB) RETURNS TEXT

-- Build query with joins for lookups
CREATE FUNCTION build_query_with_joins(p_entity_type VARCHAR) RETURNS TEXT

-- Fetch paginated list data
CREATE FUNCTION fetch_list_data(
    p_user_id UUID,
    p_entity_type VARCHAR,
    p_filters JSONB,
    p_sort_field VARCHAR,
    p_sort_direction VARCHAR,
    p_page_size INTEGER,
    p_page_number INTEGER
) RETURNS TABLE (total_count BIGINT, data JSONB)

-- Fetch single record for forms
CREATE FUNCTION fetch_form_data(
    p_user_id UUID,
    p_entity_type VARCHAR,
    p_record_id UUID
) RETURNS JSONB
```

**Filter Syntax**:
```json
{
  "status": ["approved", "submitted"],           // IN clause
  "po_date_gte": "2024-01-01",                   // >= operator
  "total_amount_gt": 10000,                      // > operator
  "supplier_name_like": "Acme%"                  // ILIKE
}
```

**Security**: All queries use parameterized values (SQL injection prevention)

### 4. HTMX Generation Functions

**Main Orchestration Functions**:

```sql
CREATE FUNCTION generate_htmx_list(
    p_user_id UUID,
    p_entity_type VARCHAR,
    p_filters JSONB,
    p_sort_field VARCHAR,
    p_sort_direction VARCHAR,
    p_page INTEGER
) RETURNS TEXT
```

**Flow**:
1. Check action permission (can user read this entity?)
2. Fetch template from htmx_templates table
3. Get field permissions for user
4. Apply permission filtering to template
5. Fetch data with RLS and filters
6. Add metadata (pagination, user permissions)
7. Render template with data
8. Log performance metrics
9. Return HTML

```sql
CREATE FUNCTION generate_htmx_form(
    p_user_id UUID,
    p_entity_type VARCHAR,
    p_form_type VARCHAR,    -- 'create', 'edit', 'view'
    p_record_id UUID
) RETURNS TEXT
```

**Flow**: Similar to list, but for single record forms

### 5. Business Workflow Functions

**Purchase Order Lifecycle**:
```sql
CREATE FUNCTION create_purchase_order(p_user_id UUID, p_po_data JSONB)
    RETURNS UUID

CREATE FUNCTION submit_purchase_order(p_user_id UUID, p_po_id UUID)
    RETURNS BOOLEAN

CREATE FUNCTION approve_purchase_order(p_user_id UUID, p_po_id UUID)
    RETURNS BOOLEAN
```

**Goods Receipt**:
```sql
CREATE FUNCTION create_goods_receipt(
    p_user_id UUID,
    p_po_id UUID,
    p_gr_data JSONB
) RETURNS UUID
-- Updates quantity_received on PO lines
-- Auto-updates PO status to fully_received when complete
```

**Invoice with 3-Way Matching**:
```sql
CREATE FUNCTION create_invoice_receipt(
    p_user_id UUID,
    p_invoice_data JSONB
) RETURNS UUID
-- Compares invoice vs PO vs GR
-- Detects price variances
-- Detects quantity variances (over-invoicing)
-- Sets matching_status: 'matched', 'variance', 'pending'
```

**Payment Processing**:
```sql
CREATE FUNCTION create_payment(p_user_id UUID, p_payment_data JSONB)
    RETURNS UUID
-- Validates payment amount <= invoice amount
-- Supports split payments

CREATE FUNCTION process_payment(p_user_id UUID, p_payment_id UUID)
    RETURNS BOOLEAN

CREATE FUNCTION clear_payment(p_user_id UUID, p_clearing_id UUID)
    RETURNS BOOLEAN
```

**Generic CRUD**:
```sql
CREATE FUNCTION update_record(
    p_user_id UUID,
    p_entity_type VARCHAR,
    p_record_id UUID,
    p_updates JSONB
) RETURNS BOOLEAN

CREATE FUNCTION soft_delete_record(
    p_user_id UUID,
    p_entity_type VARCHAR,
    p_record_id UUID
) RETURNS BOOLEAN
```

---

## Implementation Phases

### Phase 1: Foundation & Database Setup (Days 1-3)

**Objectives**:
- Set up development environment
- Create complete database schema
- Implement basic infrastructure

**Tasks**:
1. Environment setup (PostgreSQL/Supabase, Node.js)
2. Create migration files for all 18 tables
3. Add foreign key constraints and indexes
4. Set up sequences for auto-numbering
5. Create triggers for `updated_at` auto-update
6. Implement RLS policies
7. Create database roles

**Deliverables**:
- ✅ Complete database schema
- ✅ All tables created with constraints
- ✅ Indexes in place
- ✅ Migration scripts ready

**Success Criteria**:
- All tables created without errors
- Foreign key relationships work
- Indexes created successfully

### Phase 2: Template & Permission System (Days 4-7)

**Objectives**:
- Build template rendering engine
- Implement permission resolution
- Seed initial data

**Tasks**:
1. Implement `render_template()` function
2. Implement `apply_field_permissions()` function
3. Write unit tests (pgTAP) for templates
4. Implement permission functions
5. Set up permission caching
6. Create 5 roles and permission matrix
7. Seed test users

**Deliverables**:
- ✅ Working template renderer
- ✅ Permission system functions
- ✅ Master data seeded
- ✅ Unit tests passing

**Success Criteria**:
- Template rendering works correctly
- Permission checks return correct results
- All test users have proper role assignments

### Phase 3: Data Layer & Query Building (Days 8-11)

**Objectives**:
- Build dynamic query system
- Implement data fetching with security
- Optimize performance

**Tasks**:
1. Implement `build_where_clause()` function
2. Implement `build_query_with_joins()` function
3. Implement `fetch_list_data()` function
4. Implement `fetch_form_data()` function
5. Create composite indexes for common filters
6. Test query performance with EXPLAIN ANALYZE
7. Implement cursor-based pagination

**Deliverables**:
- ✅ Dynamic query builder
- ✅ Data fetching functions
- ✅ Optimized indexes
- ✅ Unit tests for queries

**Success Criteria**:
- Filters work correctly
- Sorting works
- Lookups joined properly
- Performance < 200ms for 10k records

### Phase 4: HTMX Generation (Days 12-15)

**Objectives**:
- Implement main UI generation functions
- Create sample templates
- Test end-to-end generation

**Tasks**:
1. Implement `generate_htmx_list()` function
2. Implement `generate_htmx_form()` function
3. Create list template with filters, sorting, pagination
4. Create form templates (create/edit/view)
5. Store templates in htmx_templates table
6. Add performance logging
7. End-to-end testing

**Deliverables**:
- ✅ UI generation functions working
- ✅ Sample templates for all view types
- ✅ Performance logging active
- ✅ E2E tests passing

**Success Criteria**:
- List generation < 300ms p95
- Form generation < 200ms
- Template cache hit rate > 85%

### Phase 5: Business Logic (Days 16-20)

**Objectives**:
- Implement procurement workflow functions
- Add validation logic
- Test complete workflows

**Tasks**:
1. Implement PO functions (create/submit/approve)
2. Implement GR functions
3. Implement invoice functions with 3-way matching
4. Implement payment functions
5. Add generic CRUD functions
6. Status validation and transitions
7. Workflow testing

**Deliverables**:
- ✅ All workflow functions implemented
- ✅ Validation logic in place
- ✅ Status transitions working
- ✅ Complete P2P cycle tested

**Success Criteria**:
- Complete P2P workflow executes correctly
- 3-way matching works accurately
- Partial receipts handled
- Payment validation works

### Phase 6: API Layer (Days 21-23)

**Objectives**:
- Build minimal Fastify server
- Integrate Supabase Auth
- Create REST endpoints

**Tasks**:
1. Initialize Fastify project
2. Set up Supabase client
3. Configure auth middleware
4. Create UI routes (list, form)
5. Create business logic routes
6. Add error handling
7. Create frontend shell (index.html)

**Deliverables**:
- ✅ Fastify server running
- ✅ All API endpoints working
- ✅ Auth middleware active
- ✅ Frontend shell ready

**Success Criteria**:
- API responds correctly
- Authentication works
- HTMX interactions smooth
- Error handling works

### Phase 7: Testing & Optimization (Days 24-28)

**Objectives**:
- Run comprehensive test suite
- Performance tuning
- Load testing
- Security validation

**Tasks**:
1. Run all functional tests (28 tests)
2. Run performance tests (20 tests)
3. Run load tests (5 scenarios)
4. Run security tests (SQL injection, permissions)
5. Run data integrity tests
6. Optimize slow queries
7. Tune indexes and caching

**Deliverables**:
- ✅ All tests passing
- ✅ Performance metrics documented
- ✅ Load test results
- ✅ Security audit complete
- ✅ Optimization report

**Success Criteria**:
- 100% functional test pass rate
- Performance targets met
- System handles 50 concurrent users
- No security vulnerabilities

### Phase 8: Test Data & Documentation (Days 29-30)

**Objectives**:
- Generate test datasets
- Write comprehensive documentation
- Create admin dashboard

**Tasks**:
1. Generate test datasets (100, 1k, 10k, 100k records)
2. Write database schema docs
3. Write API endpoint docs
4. Create developer guides
5. Build admin dashboard (optional)
6. Final testing against all dataset sizes

**Deliverables**:
- ✅ Test datasets generated
- ✅ Comprehensive documentation
- ✅ Developer guides complete
- ✅ Admin dashboard (if time permits)

**Success Criteria**:
- All dataset sizes load successfully
- Documentation complete and clear
- New developers can add entities

---

## Testing Strategy

### Testing Pyramid

```
             /\
            /  \    E2E Tests (10%)
           /----\
          /      \  Integration Tests (30%)
         /--------\
        /          \ Unit Tests (60%)
       /____________\
```

### Test Categories

#### 1. Unit Tests (Database Functions)

**Tool**: pgTAP

**Coverage**:
- Template rendering (simple, nested, arrays, escaping)
- Permission resolution
- Query building
- Data fetching

**Example**:
```sql
BEGIN;
SELECT plan(5);

SELECT is(
    render_template('<div>{{name}}</div>', '{"name": "John"}'::JSONB),
    '<div>John</div>',
    'Simple placeholder replacement works'
);

SELECT * FROM finish();
ROLLBACK;
```

**Run**: `pg_prove tests/unit/*.test.sql`

#### 2. Integration Tests (API Endpoints)

**Tool**: Jest + Supertest

**Coverage**:
- API endpoint responses
- Authentication
- Error handling
- HTMX attribute presence

**Example**:
```javascript
test('GET /ui/purchase_order/list returns HTML', async () => {
    const response = await request(app)
        .get('/ui/purchase_order/list')
        .set('Authorization', `Bearer ${authToken}`);

    expect(response.status).toBe(200);
    expect(response.headers['content-type']).toContain('text/html');
    expect(response.text).toContain('<table');
});
```

**Run**: `npm run test:integration`

#### 3. Functional Tests (Complete Workflows)

**Tool**: Jest

**Coverage**:
- Complete P2P cycle
- 3-way matching scenarios
- Partial receipts
- Payment workflows
- Permission enforcement

**Example**:
```javascript
test('Full P2P cycle: PO → GR → Invoice → Payment', async () => {
    const po = await createPO({...});
    await submitPO(po.po_id);
    await approvePO(po.po_id);
    const gr = await createGR({...});
    const invoice = await createInvoice({...});
    expect(invoice.matching_status).toBe('matched');
    // ... complete cycle
});
```

**Run**: `npm run test:functional`

#### 4. Performance Tests

**Tool**: k6

**Coverage**:
- List generation time (100, 1k, 10k, 100k records)
- Form generation time
- Permission resolution speed
- Template rendering speed
- Concurrent user handling

**Targets**:
- List generation < 300ms p95 for 10k records
- Form generation < 200ms p95
- Template cache hit rate > 85%

**Example**:
```javascript
export let options = {
    thresholds: {
        http_req_duration: ['p(95)<300'],
        http_req_failed: ['rate<0.01'],
    },
};

export default function () {
    let response = http.get(`${BASE_URL}/ui/purchase_order/list`, params);
    check(response, {
        'response time < 300ms': (r) => r.timings.duration < 300,
    });
}
```

**Run**: `npm run test:performance`

#### 5. Load Tests

**Tool**: k6

**Scenarios**:
- Sustained load: 10 req/sec for 5 minutes
- Sustained load: 50 req/sec for 5 minutes
- Spike test: 0 to 100 req/sec
- Gradual ramp: 1 to 100 req/sec over 10 minutes
- Mixed workload: 60% lists, 30% forms, 10% writes

**Targets**:
- 50 concurrent users with < 1s p95 latency
- < 1% error rate under load
- No memory leaks

**Run**: `npm run test:load`

#### 6. Security Tests

**Coverage**:
- SQL injection attempts
- Permission bypass attempts
- Row-level security enforcement
- Field permission bypass attempts
- XSS prevention in templates

**Example**:
```javascript
test('SQL injection in filter is prevented', async () => {
    const maliciousFilter = {
        status: "'; DROP TABLE purchase_orders; --"
    };

    const response = await request(app)
        .get('/ui/purchase_order/list')
        .query({ filters: JSON.stringify(maliciousFilter) });

    // Should not execute injection, should return error or no results
    expect(response.status).not.toBe(500);
});
```

**Run**: `npm run test:security`

#### 7. Data Integrity Tests

**Coverage**:
- Referential integrity
- Cascade behavior
- Quantity reconciliation
- Amount validation
- Status consistency
- Concurrent updates

**Example**:
```javascript
test('Cannot over-receive goods beyond PO quantity', async () => {
    const po = await createPO({ quantity_ordered: 100 });
    await approvePO(po.po_id);

    await expect(
        createGR({ po_id: po.po_id, quantity_received: 120 })
    ).rejects.toThrow('Cannot receive more than ordered');
});
```

**Run**: `npm run test:integrity`

### Test Execution Matrix

| Test Type | Tool | Count | Frequency | Duration |
|-----------|------|-------|-----------|----------|
| Unit | pgTAP | ~30 | On commit | < 1 min |
| Integration | Jest | ~20 | On commit | 2-3 min |
| Functional | Jest | ~28 | On PR | 5-10 min |
| Performance | k6 | ~20 | Daily | 10-15 min |
| Load | k6 | ~5 | Weekly | 30-60 min |
| Security | Jest | ~10 | On PR | 2-3 min |
| Data Integrity | Jest | ~10 | On PR | 2-3 min |

### CI/CD Integration

**GitHub Actions Workflow**:
```yaml
on: [push, pull_request]

jobs:
  test:
    steps:
      - Run unit tests
      - Run integration tests
      - Run functional tests
      - Run security tests
      - Report coverage

  performance:
    if: github.event_name == 'pull_request'
    steps:
      - Run performance tests
      - Compare against baseline
      - Comment on PR with results
```

---

## Success Metrics

### Functional Requirements

- [ ] ✅ All 28 functional tests pass (100%)
- [ ] ✅ Complete P2P workflow executes correctly
- [ ] ✅ 3-way matching detects variances accurately
- [ ] ✅ Permission system enforces all rules
- [ ] ✅ Partial receipts and split payments work
- [ ] ✅ Soft deletes preserve referential integrity
- [ ] ✅ Audit trail captures all actions

### Performance Requirements

- [ ] ✅ List generation < 100ms avg for 100 records
- [ ] ✅ List generation < 150ms avg for 1,000 records
- [ ] ✅ List generation < 200ms avg for 10,000 records
- [ ] ✅ List generation < 300ms avg for 100,000 records
- [ ] ✅ List generation < 300ms p95 for all datasets
- [ ] ✅ Form generation < 50ms avg (simple)
- [ ] ✅ Form generation < 100ms avg (with lookups)
- [ ] ✅ Form generation < 200ms p95
- [ ] ✅ Permission resolution < 50ms (cold cache)
- [ ] ✅ Permission resolution < 5ms (warm cache)
- [ ] ✅ Template cache hit rate > 85%

### Scalability Requirements

- [ ] ✅ System handles 10 concurrent users (< 500ms p95)
- [ ] ✅ System handles 50 concurrent users (< 1000ms p95)
- [ ] ✅ System handles 100 concurrent users (< 2000ms p95)
- [ ] ✅ Sustained 10 req/sec for 5 min (< 0.1% errors)
- [ ] ✅ Sustained 50 req/sec for 5 min (< 1% errors)
- [ ] ✅ Spike from 0 to 100 req/sec handled gracefully

### Security Requirements

- [ ] ✅ No SQL injection vulnerabilities
- [ ] ✅ All permission checks enforced
- [ ] ✅ Row-level security works correctly
- [ ] ✅ Field permissions cannot be bypassed
- [ ] ✅ HTML escaping prevents XSS
- [ ] ✅ Authentication required for all endpoints

### Data Integrity Requirements

- [ ] ✅ Zero referential integrity violations
- [ ] ✅ Quantity reconciliation accurate
- [ ] ✅ Amount validation prevents overpayment
- [ ] ✅ Status transitions follow rules
- [ ] ✅ Concurrent updates handled correctly

### Code Quality Requirements

- [ ] ✅ Test coverage > 80%
- [ ] ✅ All critical paths tested
- [ ] ✅ Documentation complete
- [ ] ✅ Code follows conventions
- [ ] ✅ No linter errors

---

## Risk Management

### High-Risk Areas

#### 1. Template Rendering Complexity
**Risk**: Custom parser in PL/pgSQL is complex and may have bugs or performance issues

**Mitigation**:
- Start with simple placeholder replacement
- Add features incrementally
- Extensive unit testing
- Performance benchmarking at each step

**Contingency**:
- If performance inadequate → Move to application layer (Handlebars.js)
- If bugs persist → Use proven templating engine

#### 2. Performance at Scale
**Risk**: 100k records might strain database queries

**Mitigation**:
- Early performance testing
- Cursor-based pagination for large offsets
- Materialized views for complex aggregations
- Aggressive caching strategy

**Contingency**:
- Add read replicas if needed
- Implement application-layer caching (Redis)
- Use CDN for static content

#### 3. Permission System Complexity
**Risk**: Many permission levels could have gaps or conflicts

**Mitigation**:
- Clear documentation of permission precedence
- Comprehensive test suite
- Default-deny approach
- Regular security audits

**Contingency**:
- Simplify permission model if too complex
- Add permission debugging tools
- Implement permission simulation/preview

#### 4. Dynamic Query Building
**Risk**: SQL injection or performance issues

**Mitigation**:
- Use parameterized queries exclusively
- Whitelist allowed operators
- Query plan analysis
- Rate limiting on complex filters

**Contingency**:
- Pre-define common query patterns
- Limit filter complexity
- Add query timeout limits

#### 5. Data Migration & Schema Changes
**Risk**: Schema changes could break existing templates

**Mitigation**:
- Version control for templates
- Database migration testing
- Backward compatibility checks
- Rollback procedures

**Contingency**:
- Template versioning system
- Schema change notifications
- Automated template validation

### Medium-Risk Areas

#### 6. Supabase Limitations
**Risk**: RLS performance or feature gaps

**Mitigation**:
- Test RLS performance early
- Have fallback to application-layer security
- Monitor Supabase updates

**Contingency**:
- Move to self-hosted PostgreSQL if needed
- Implement security in application layer

#### 7. HTMX Limitations
**Risk**: Complex UI interactions may exceed HTMX capabilities

**Mitigation**:
- Prototype complex interactions early
- Have Alpine.js as backup for client-side logic
- Design UI for server-side rendering

**Contingency**:
- Add minimal JavaScript where needed
- Use Alpine.js for complex client logic
- Consider React for specific components

#### 8. Test Data Generation
**Risk**: Realistic test data is hard to generate

**Mitigation**:
- Use Faker.js for realistic data
- Model real-world distributions
- Include edge cases

**Contingency**:
- Import anonymized production data
- Manual test data creation
- Synthetic data generation tools

### Low-Risk Areas

#### 9. API Layer Simplicity
**Risk**: Minimal - API is just a proxy

**Mitigation**: Good Fastify documentation, simple patterns

#### 10. Authentication Integration
**Risk**: Minimal - Supabase Auth is proven

**Mitigation**: Follow Supabase best practices

---

## Project File Structure

```
htmx_db/
├── database/
│   ├── migrations/
│   │   ├── 001_create_business_domain.sql
│   │   ├── 002_create_ui_framework.sql
│   │   ├── 003_create_audit_tables.sql
│   │   ├── 004_create_indexes.sql
│   │   └── 005_create_rls_policies.sql
│   ├── functions/
│   │   ├── template_engine/
│   │   │   ├── render_template.sql
│   │   │   └── apply_field_permissions.sql
│   │   ├── permissions/
│   │   │   ├── get_user_field_permissions.sql
│   │   │   ├── can_user_perform_action.sql
│   │   │   └── evaluate_condition.sql
│   │   ├── data_layer/
│   │   │   ├── fetch_list_data.sql
│   │   │   ├── fetch_form_data.sql
│   │   │   ├── build_where_clause.sql
│   │   │   └── build_query_with_joins.sql
│   │   ├── ui_generation/
│   │   │   ├── generate_htmx_list.sql
│   │   │   └── generate_htmx_form.sql
│   │   └── business_logic/
│   │       ├── purchase_order_functions.sql
│   │       ├── goods_receipt_functions.sql
│   │       ├── invoice_functions.sql
│   │       └── payment_functions.sql
│   └── seed/
│       ├── master_data.sql
│       ├── test_data_small.sql
│       ├── test_data_medium.sql
│       └── test_data_large.sql
├── api/
│   ├── src/
│   │   ├── middleware/
│   │   │   ├── auth.js
│   │   │   ├── error.js
│   │   │   └── logging.js
│   │   ├── routes/
│   │   │   ├── ui.js
│   │   │   ├── business.js
│   │   │   └── health.js
│   │   ├── utils/
│   │   │   ├── supabase.js
│   │   │   └── validation.js
│   │   └── server.js
│   ├── public/
│   │   ├── index.html
│   │   └── styles.css
│   ├── package.json
│   └── .env.example
├── tests/
│   ├── unit/
│   │   ├── template_rendering.test.sql
│   │   ├── permissions.test.sql
│   │   └── data_fetching.test.sql
│   ├── integration/
│   │   ├── api.test.js
│   │   └── ui_generation.test.js
│   ├── functional/
│   │   ├── procurement_workflow.test.js
│   │   └── three_way_matching.test.js
│   ├── performance/
│   │   ├── list_generation.k6.js
│   │   └── form_generation.k6.js
│   ├── load/
│   │   ├── sustained_load.k6.js
│   │   └── spike_test.k6.js
│   ├── security/
│   │   ├── sql_injection.test.js
│   │   └── permission_bypass.test.js
│   ├── fixtures/
│   │   ├── seed_data.sql
│   │   └── test_users.sql
│   ├── helpers/
│   │   ├── db_setup.js
│   │   └── test_data_generator.js
│   ├── jest.config.js
│   └── setup.js
├── docs/
│   ├── DATABASE_SCHEMA.md
│   ├── API_ENDPOINTS.md
│   ├── ADDING_ENTITIES.md
│   ├── TEMPLATE_GUIDE.md
│   └── PERMISSIONS_GUIDE.md
├── .github/
│   └── workflows/
│       └── test.yml
├── PROJECT_PLAN.md (this file)
├── README.md
├── prompt.md
└── .gitignore
```

---

## Next Steps

### Immediate Actions (Week 1)

1. **Set up development environment**
   - [ ] Install PostgreSQL 14+ or create Supabase project
   - [ ] Initialize Node.js project
   - [ ] Set up Git repository
   - [ ] Create project structure

2. **Begin Phase 1: Database Setup**
   - [ ] Create migration files
   - [ ] Define all 18 tables
   - [ ] Add constraints and indexes
   - [ ] Test migrations

3. **Documentation**
   - [ ] Set up docs folder
   - [ ] Begin schema documentation
   - [ ] Create developer setup guide

### Questions to Resolve

1. **Deployment Target**: Supabase cloud or self-hosted PostgreSQL?
2. **Frontend Framework**: Pure HTMX or add Alpine.js for complex interactions?
3. **Caching Layer**: In-memory only or add Redis?
4. **CI/CD Platform**: GitHub Actions, GitLab CI, or other?
5. **Monitoring**: What APM/monitoring tools to use?

### Resources Needed

- [ ] Supabase account (free tier sufficient for development)
- [ ] Development database
- [ ] Test/staging database
- [ ] GitHub repository
- [ ] Domain name (for production deployment)

---

## Appendix

### A. Key PostgreSQL Functions Summary

| Function | Purpose | Returns |
|----------|---------|---------|
| `render_template()` | Replace placeholders with data | TEXT (HTML) |
| `apply_field_permissions()` | Filter template by permissions | TEXT (HTML) |
| `get_user_field_permissions()` | Get field visibility/editability | TABLE |
| `can_user_perform_action()` | Check action permission | BOOLEAN |
| `evaluate_condition()` | Evaluate dynamic rules | BOOLEAN |
| `fetch_list_data()` | Get paginated, filtered list | TABLE (count, JSONB) |
| `fetch_form_data()` | Get single record with lookups | JSONB |
| `generate_htmx_list()` | Generate complete list HTML | TEXT (HTML) |
| `generate_htmx_form()` | Generate complete form HTML | TEXT (HTML) |
| `create_purchase_order()` | Create PO with lines | UUID |
| `submit_purchase_order()` | Submit PO for approval | BOOLEAN |
| `approve_purchase_order()` | Approve PO | BOOLEAN |
| `create_goods_receipt()` | Create GR, update PO qtys | UUID |
| `create_invoice_receipt()` | Create invoice, 3-way match | UUID |
| `create_payment()` | Create payment record | UUID |
| `process_payment()` | Process payment | BOOLEAN |

### B. Standard Roles & Permissions

| Role | Purchase Orders | Goods Receipts | Invoices | Payments |
|------|----------------|----------------|----------|----------|
| **Admin** | Full access | Full access | Full access | Full access |
| **Purchase Manager** | Create, Edit, Submit | View | View | View |
| **Warehouse Staff** | View | Create, Edit | - | - |
| **Accountant** | View | View | Create, Verify, Approve | Create, Process |
| **Viewer** | View only | View only | View only | View only |

### C. Performance Targets Summary

| Metric | Target | Measurement |
|--------|--------|-------------|
| List (100 records) | < 100ms avg | p95 < 200ms |
| List (1k records) | < 150ms avg | p95 < 300ms |
| List (10k records) | < 200ms avg | p95 < 400ms |
| List (100k records) | < 300ms avg | p95 < 600ms |
| Form generation | < 100ms avg | p95 < 200ms |
| Permission check (cold) | < 50ms | - |
| Permission check (warm) | < 5ms | - |
| Template cache hit rate | > 85% | - |
| 10 concurrent users | < 500ms p95 | < 0.1% errors |
| 50 concurrent users | < 1000ms p95 | < 1% errors |
| 100 concurrent users | < 2000ms p95 | < 1% errors |

### D. Glossary

**3-Way Matching**: Comparing Purchase Order, Goods Receipt, and Invoice to detect variances
**HTMX**: HTML over the wire - JavaScript library for building dynamic interfaces
**PL/pgSQL**: Procedural Language/PostgreSQL - SQL procedural language
**RLS**: Row Level Security - PostgreSQL feature for data access control
**Soft Delete**: Marking records as deleted without physically removing them
**P2P**: Procure-to-Pay - Complete procurement lifecycle
**pgTAP**: TAP-compliant testing framework for PostgreSQL
**k6**: Modern load testing tool

---

## License

This project and documentation are proprietary.

## Contributors

- **happyveggie** - Project Lead & Implementation
- **Claude Sonnet 4.5** (Anthropic) - Architecture Design & Planning

---

**Document Version**: 1.0
**Last Updated**: 2026-01-16
**Status**: Planning Complete, Ready for Implementation
